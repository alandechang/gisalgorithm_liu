<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>招牌菜</title>
	<style>
.button {
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: right;
    text-decoration: none;
    font-size: 30px;
    margin: 4px 2px;
    cursor: pointer;
}

</style>

</head>
<body>
<h1 align="center"><font face="宋体" color="#CC0000" align="center">中国地图</font></h1>
		<div>
		<div style="width: 90%;">
		<input type="file" style="visibility: hidden;" id="fileRead" onchange="ShowMap()">
		<span class="button"><button  type="button" onclick="fileRead.click()">加载</button></span>压缩百分比%
		<select style="height:25px;" id="type2">
			<option value="geography">20%</option>
			<option value="lambert">30%</option>
			<option value="mercator">50%</option>
		</select>
		<span class="button"><button  type="button" onclick="DrawGird(change)">经纬网</button></span>
		<span class="button"><button  type="button" value="lambert" onclick="setValue(this.value)">兰伯特</button></span>
		<span class="button"><button  type="button" value="mercator" onclick="setValue(this.value)">墨卡托</button></span>

		<label><input type="radio" name="yasuoqian" value="0" onclick="setValue(this.value)">压缩前</label>
		<label><input type="radio" name="yasuohou" value="50" onclick="setValue(this.value)">压缩后</label>
		
		</div>
	
		</div>
		<div style="width: 1092px; ">
		<canvas id="map" width="1280" height="570" style="border:1px solid #000;margin-top:5px absolute;margin-left: 10%;"></canvas>
		</div>
		<script>
			var canvas = document.getElementById('map');//获取画布的id“map”
			var ctx = canvas.getContext('2d');//获取绘画的2d环境
			canvas.width = 1280;
			canvas.height = 570;
			var change="china";
			var e2, e02, a, b,A,B,C;
			var kexi=0.001;
			var istrue=1;
			var jilu,start,end;var l=0;
			var fanhui;

			function setValue(value) {
				change = value;
				ShowMap();
			}
			function ShowMap() {
		

					e2 = 0.006693421622966; //克拉索夫斯基椭球体的第一偏心率
					e02 = 0.006738525414683; //克拉索夫斯基椭球体的第二偏心率
					a = 6378245; //克拉索夫斯基椭球体的长半径
					b = 6356863.0187730473; //克拉索夫斯基椭球体的短半径

				var file = document.getElementById('fileRead').files[0];
				var reader = new FileReader();
				reader.readAsText(file);//按异步字符串
				var data = null;
				reader.onload = function(e) {//当读取操作完成时调用
					data = this.result;
					ClearCanvas();
					DrawMap(change,data);
				}
			}
			
			/*function DrawMap(change,data) {
				ctx.strokeStyle = "black";
				data = data.split('\r\n');
				var count = 0;
				for(var i = 0; i < data.length; i++) {
					var line = data[i];
					if(line == "END") {
						ctx.stroke();
						count = 0;
						continue;
					}
					var point = line.split(',');
					if(point.length < 2) {
						count = 1;
						continue;
					}
					if(count == 1) {
						ctx.beginPath();
						var t = GetPoint(change, point[0], point[1]);
						ctx.moveTo(t[0], t[1]);
						count++;
					} else {
						var t = GetPoint(change, point[0], point[1]);
						ctx.lineTo(t[0], t[1]);
					}
				}
			}*/
			function DrawMap(change,data){
				ctx.strokeStyle="balck";
				data=data.split('\r\n');
				var count=0;
				for(var i=0;i<data.length;i++){
					var line=data[i];
					
					if(line=="END"){
					fanhui=[];
					ctx.stroke();
					var t;
					var static j=1;
					for(var h=0;j<i;j++){
					t=line[j];h++;
					}
						j+=2;
						Dogkela(t,0,h,h);
					}
					var point = fanhui.split(',');
					if(point.length < 2) {
						count = 1;
						continue;
					}
					if(count == 1) {
						ctx.beginPath();
						var t = GetPoint(change, point[0], point[1]);
						ctx.moveTo(t[0], t[1]);
						count++;
					} else {
						var t = GetPoint(change, point[0], point[1]);
						ctx.lineTo(t[0], t[1]);
					}
				
				}
			}
			Dogkela(t,start,end,h){
				for(var k=0;k<=end;k++){
				var point=t.split(',');
				if(k==0){
				xm=point[0];ym=point[1];
				}
				if(k==end){
				xn=point[0];yn=point[1];
				}
				}
				jilu=h;
				Calculateline(xm,ym,xn,yn);
				for(var k=1;k<end-1;k++){
				var point=t.split(',');
				d=Math.abs(A*point[0]+B*point[1]+C);
				var paixushuzu[k-1]=d;
				var maxd=d;
				if(d>maxd)
				{var logo=k-1;
				maxd=d;}
				}
				if(d<=kexi){if(istrue==1){
				
				fanhui[l]=t[start];
				fanhui[++l]=t[end];
				return fanhui;
				l=0;
				}
				if(istrue==0){
				funhui[++l]=t[end];
				start=end;edn=h;
				istrue=1;
				}
				}
				if(d>kexi){istrue=0;
				end=logo;
				Dogkela(t,start,end,h);
				fanhui[l]=t[start];
				fanhui[++l]=t[end];
				}
			
				
			}
			Calculateline(xm,ym,xn,yn){
				A= (ym-yn) / Math.sqrt((ym-yn)*(ym-yn)+ (xm-xn)*(xm-xn));
				B= (xn-xm) / Math.sqrt((ym-yn)*(ym-yn)+ (xm-xn)*(xm-xn));
				C= (xm*yn-xn*ym) / Math.sqrt((ym-yn)*(ym-yn)+ (xm-xn)*(xm-xn));
				return A,B,C;
			}
			function DrawGird(change) {
				ctx.strokeStyle = "grey";//触笔的颜色、渐变、模式都行
				for(var i = -18; i <= 18; i++) {
					for(var j = -36; j < 36; j++) {
						var x = j * 5;
						var y = i * 5;
						var point1 = GetPoint(change, x, y);
						var point2 = GetPoint(change, x + 5, y);
						ctx.beginPath();
						ctx.moveTo(CheckFinite(point1[0]), CheckFinite(point1[1]));
						ctx.lineTo(CheckFinite(point2[0]), CheckFinite(point2[1]));
						ctx.stroke();//绘制从MoveTo（）到lineTo方法定义的路径
					}
				}

				for(var i = -36; i <= 36; i++) {
					for(var j = -18; j < 18; j++) {
						var x = i * 5;
						var y = j * 5;
						var point1 = GetPoint(change, x, y);
						var point2 = GetPoint(change, x, y + 5);
						ctx.beginPath();
						ctx.moveTo(CheckFinite(point1[0]), CheckFinite(point1[1]));
						ctx.lineTo(CheckFinite(point2[0]), CheckFinite(point2[1]));
						ctx.stroke();
					}
				}
			}
			function CheckFinite(x) {
				if(isFinite(x)) {
					return x;
				} else {
					return 9999;
				}
			}
			function GetPoint(change, x, y) {
				if(change == "lambert") {
					var point = LambertProjectionXY(x, y);
					var x0 = (point[0] - 5000000) / 10100 + 1100;
					var y0 = canvas.height - (point[1] - 1000000) / 10100 - 60;
					return [x0, y0];
				}
				if(change == "mercator") {
					var point = MercatorProjectionXY(x, y);
					var x0 = (point[0] - 13700000) / 12000 + 780;
					var y0 = canvas.height - (point[1] - 5700000) / 12000 - 450;
					return [x0, y0];
				}
				if (change == "china" )
				{
					return [(x - 40) * 10, canvas.height - y * 10];
				}
				
				
			}
			function LambertProjectionXY(L, B) {
				L = L * Math.PI / 180;//经度的弧度制
				B = B * Math.PI / 180;//纬度的弧度制

				var b1 = 20 * Math.PI / 180; //兰伯特投影的标准纬线1
				var b2 = 40 * Math.PI / 180; //兰伯特投影的标准纬线2
				var l0 = 105 * Math.PI / 180; //原点经度
				var b0 = 0; //原点纬度

				var m = Math.cos(B) / Math.sqrt(1 - e2 * Math.sin(B) * Math.sin(B));//e2北京-54第一偏心率平方，m为曲率半径
				var mb1 = Math.cos(b1) / Math.sqrt(1 - e2 * Math.sin(b1) * Math.sin(b1));//标准纬线b1处的m值
				var mb2 = Math.cos(b2) / Math.sqrt(1 - e2 * Math.sin(b2) * Math.sin(b2));//标准纬线b2处的m值
				var e = Math.sqrt(e2);//第一偏心率
				var temp = Math.tan(Math.PI / 4 - B / 2);
				var t = Math.tan(Math.PI / 4 - B / 2) / Math.pow(((1 - e * Math.sin(B)) / (1 + e * Math.sin(B))), e / 2);
				var tb1 = Math.tan(Math.PI / 4 - b1 / 2) / Math.pow(((1 - e * Math.sin(b1)) / (1 + e * Math.sin(b1))), e / 2);
				var tb2 = Math.tan(Math.PI / 4 - b2 / 2) / Math.pow(((1 - e * Math.sin(b2)) / (1 + e * Math.sin(b2))), e / 2);
				var n = Math.log(mb1 / mb2) / Math.log(tb1 / tb2);
				var F = mb1 / (n * Math.pow(tb1, n));
				var r = a * F * Math.pow(t, n);

				//计算r0，需要计算t0
				var t0 = Math.tan(Math.PI / 4 - b0 / 2) / Math.pow((1 - e * Math.sin(b0)) / (1 + e * Math.sin(b0)), e / 2);
				var r0 = a * F * Math.pow(t0, n);

				var theta = n * (L - l0);

				var X = r0 - r * Math.cos(theta);
				var Y = r * Math.sin(theta);
				return [Y, X];
			}
			function MercatorProjectionXY(L, B) {
				L = L * Math.PI / 180;
				B = B * Math.PI / 180;
				var B0 = 0;
				var L0 = 0;
				var e = Math.sqrt(e2);
				var K = (a * a / b) / Math.sqrt(1 + e02 * Math.cos(B0) * Math.cos(B0)) * Math.cos(B0);
				var X = K * Math.log(Math.tan(Math.PI / 4 + B / 2) * Math.pow(((1 - e * Math.sin(B)) / (1 + e * Math.sin(B))), e / 2));
				var Y = K * (L - L0);
				return [Y, X];
			}
			function ClearCanvas() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);//清空给定矩形内指定的像素（x，y，width，height）左上坐标
			}

		</script>
	
</body>
</html>
	